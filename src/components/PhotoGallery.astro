---
import Menu from './Menu.astro';
import { useTranslations } from '../i18n/utils';
import type { BaseComponentProps } from '../types';

export interface Props extends BaseComponentProps {
  t?: any; // Make t optional
}

const { lang = 'en', t } = Astro.props;

// Ensure we have a valid translation function
const validT = t || useTranslations(lang);

export const prerender = false;
---

<div class="min-h-screen flex flex-col">
  <!-- Skip link for screen readers -->
  <a
    href="#main-content"
    class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:bg-white focus:px-4 focus:py-2 focus:border focus:border-gray-300"
  >
    {validT('common.skipToContent')}
  </a>

  <!-- Menu - fixed at top -->
  <header class="flex-shrink-0">
    <Menu lang={lang} t={validT} />
  </header>

  <!-- Main content area -->
  <main id="main-content" class="flex-1 flex flex-col p-6 md:p-8">
    <!-- Page Title -->
    <div class="text-center mb-8 md:mb-12 lg:mb-20 flex-shrink-0">
      <h1
        class="text-gray-800 uppercase tracking-wider font-normal text-2xl sm:text-4xl"
        style="letter-spacing: 4px;"
      >
        Photo Gallery
      </h1>
    </div>

    <!-- Page Content -->
    <div class="flex-1 flex justify-center">
      <div class="w-full max-w-7xl">
        <!-- Grid Size Controls - Hidden on mobile -->
        <div class="hidden sm:flex justify-between items-center mb-6">
          <div class="flex items-center space-x-2">
            <span class="text-sm text-gray-600">Grid size:</span>
            <div class="flex space-x-1 bg-gray-100 rounded-lg p-1">
              <button id="grid-3" class="grid-size-btn px-3 py-1 text-sm rounded transition-colors" data-size="3">
                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 15 15">
                  <rect x="1" y="1" width="3.5" height="3.5"/>
                  <rect x="5.5" y="1" width="3.5" height="3.5"/>
                  <rect x="10" y="1" width="3.5" height="3.5"/>
                  <rect x="1" y="5.5" width="3.5" height="3.5"/>
                  <rect x="5.5" y="5.5" width="3.5" height="3.5"/>
                  <rect x="10" y="5.5" width="3.5" height="3.5"/>
                  <rect x="1" y="10" width="3.5" height="3.5"/>
                  <rect x="5.5" y="10" width="3.5" height="3.5"/>
                  <rect x="10" y="10" width="3.5" height="3.5"/>
                </svg>
              </button>
              <button id="grid-4" class="grid-size-btn px-3 py-1 text-sm rounded transition-colors bg-gray-800 text-white" data-size="4">
                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 17 17">
                  <rect x="1" y="1" width="3" height="3"/>
                  <rect x="5" y="1" width="3" height="3"/>
                  <rect x="9" y="1" width="3" height="3"/>
                  <rect x="13" y="1" width="3" height="3"/>
                  <rect x="1" y="5" width="3" height="3"/>
                  <rect x="5" y="5" width="3" height="3"/>
                  <rect x="9" y="5" width="3" height="3"/>
                  <rect x="13" y="5" width="3" height="3"/>
                  <rect x="1" y="9" width="3" height="3"/>
                  <rect x="5" y="9" width="3" height="3"/>
                  <rect x="9" y="9" width="3" height="3"/>
                  <rect x="13" y="9" width="3" height="3"/>
                  <rect x="1" y="13" width="3" height="3"/>
                  <rect x="5" y="13" width="3" height="3"/>
                  <rect x="9" y="13" width="3" height="3"/>
                  <rect x="13" y="13" width="3" height="3"/>
                </svg>
              </button>
              <button id="grid-5" class="grid-size-btn px-3 py-1 text-sm rounded transition-colors" data-size="5">
                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 12 12">
                  <rect x="1" y="1" width="1.5" height="1.5"/>
                  <rect x="3" y="1" width="1.5" height="1.5"/>
                  <rect x="5" y="1" width="1.5" height="1.5"/>
                  <rect x="7" y="1" width="1.5" height="1.5"/>
                  <rect x="9" y="1" width="1.5" height="1.5"/>
                  <rect x="1" y="3" width="1.5" height="1.5"/>
                  <rect x="3" y="3" width="1.5" height="1.5"/>
                  <rect x="5" y="3" width="1.5" height="1.5"/>
                  <rect x="7" y="3" width="1.5" height="1.5"/>
                  <rect x="9" y="3" width="1.5" height="1.5"/>
                  <rect x="1" y="5" width="1.5" height="1.5"/>
                  <rect x="3" y="5" width="1.5" height="1.5"/>
                  <rect x="5" y="5" width="1.5" height="1.5"/>
                  <rect x="7" y="5" width="1.5" height="1.5"/>
                  <rect x="9" y="5" width="1.5" height="1.5"/>
                  <rect x="1" y="7" width="1.5" height="1.5"/>
                  <rect x="3" y="7" width="1.5" height="1.5"/>
                  <rect x="5" y="7" width="1.5" height="1.5"/>
                  <rect x="7" y="7" width="1.5" height="1.5"/>
                  <rect x="9" y="7" width="1.5" height="1.5"/>
                  <rect x="1" y="9" width="1.5" height="1.5"/>
                  <rect x="3" y="9" width="1.5" height="1.5"/>
                  <rect x="5" y="9" width="1.5" height="1.5"/>
                  <rect x="7" y="9" width="1.5" height="1.5"/>
                  <rect x="9" y="9" width="1.5" height="1.5"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="text-sm text-gray-500">
            <span id="photo-count">0</span> photos
          </div>
        </div>
        
        <!-- Mobile photo count - visible only on mobile -->
        <div class="sm:hidden flex justify-end mb-4">
          <div class="text-sm text-gray-500">
            <span id="photo-count-mobile">0</span> photos
          </div>
        </div>

        <div id="photo-gallery" class="w-full">
  <!-- Loading State -->
  <div id="loading" class="text-center py-12">
    <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900"></div>
    <p class="mt-2 text-gray-600">Loading photos...</p>
  </div>

  <!-- Error State -->
  <div id="error" class="text-center py-12 hidden">
    <p class="text-red-600">Failed to load photos. Please try again later.</p>
    <button id="retry-btn" class="mt-4 px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
      Retry
    </button>
  </div>

  <!-- Photo Grid -->
  <div id="photo-grid" class="photo-grid gap-4 hidden" data-size="4">
    <!-- Photos will be dynamically inserted here -->
  </div>

  <!-- Empty State -->
  <div id="empty-state" class="text-center py-12 hidden">
    <p class="text-gray-600">No photos have been uploaded yet.</p>
  </div>
        </div>
      </div>
    </div>
  </main>
</div>

<!-- Lightbox Modal -->
<div id="lightbox" class="fixed inset-0 bg-black bg-opacity-95 z-50 hidden">
  <div class="relative w-full h-full flex items-center justify-center">
    <!-- Close Button - Fixed position, always visible -->
    <button
      id="lightbox-close"
      class="fixed top-4 right-4 w-12 h-12 bg-black bg-opacity-60 hover:bg-opacity-80 rounded-full flex items-center justify-center text-white text-xl transition-all duration-200 z-50 shadow-lg"
      aria-label="Close lightbox"
    >
      ×
    </button>
    
    <!-- Previous Button -->
    <button
      id="lightbox-prev"
      class="absolute left-4 text-white text-4xl hover:text-gray-300 z-10 p-2 hidden"
      aria-label="Previous photo"
    >
      ‹
    </button>
    
    <!-- Next Button -->
    <button
      id="lightbox-next"
      class="absolute right-4 text-white text-4xl hover:text-gray-300 z-10 p-2 hidden"
      aria-label="Next photo"
    >
      ›
    </button>
    
    <!-- Image Container -->
    <div class="flex flex-col items-center justify-center max-w-full max-h-full p-4">
      <img
        id="lightbox-image"
        class="max-w-full max-h-[calc(100vh-8rem)] object-contain"
        alt="Photo"
      />
      
      <!-- Controls underneath the image -->
      <div class="flex items-center justify-between w-full max-w-sm mt-4 px-4">
        <!-- Photo Counter -->
        <div id="photo-counter" class="text-white text-sm">
          <span id="current-photo">1</span> / <span id="total-photos">1</span>
        </div>
        
        <!-- Download Button -->
        <button
          id="download-original"
          class="flex items-center space-x-2 bg-white bg-opacity-20 hover:bg-opacity-30 text-white px-4 py-2 rounded-full transition-all duration-200"
          title="Download original photo"
          aria-label="Download photo"
        >
          <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd"/>
          </svg>
          <span class="text-sm">Download</span>
        </button>
      </div>
    </div>
  </div>
</div>

<style>
/* Grid size variations with performance optimizations */
.photo-grid {
  display: grid;
  contain: layout style;
  transform: translateZ(0); /* Force GPU layer */
}


/* Mobile: Always single column, Desktop: User choice */
.photo-grid {
  grid-template-columns: repeat(1, 1fr);
}

@media (min-width: 640px) {
  .photo-grid[data-size="3"] {
    grid-template-columns: repeat(2, 1fr);
  }
}
@media (min-width: 1024px) {
  .photo-grid[data-size="3"] {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (min-width: 640px) {
  .photo-grid[data-size="4"] {
    grid-template-columns: repeat(3, 1fr);
  }
}
@media (min-width: 1024px) {
  .photo-grid[data-size="4"] {
    grid-template-columns: repeat(4, 1fr);
  }
}

@media (min-width: 640px) {
  .photo-grid[data-size="5"] {
    grid-template-columns: repeat(3, 1fr);
  }
}
@media (min-width: 768px) {
  .photo-grid[data-size="5"] {
    grid-template-columns: repeat(4, 1fr);
  }
}
@media (min-width: 1024px) {
  .photo-grid[data-size="5"] {
    grid-template-columns: repeat(5, 1fr);
  }
}

/* Button styles */
.grid-size-btn:not(.bg-gray-800) {
  @apply text-gray-600 hover:bg-gray-200;
}

/* Mobile scrolling optimizations */
@media (max-width: 640px) {
  .photo-item {
    contain: layout style;
    will-change: auto;
  }
  
  .lazy-image-container {
    contain: layout;
  }
  
  /* Prevent reflows during image loading */
  .lazy-placeholder {
    backface-visibility: hidden;
    transform: translateZ(0);
  }
  
  /* Smooth scrolling on mobile */
  body {
    -webkit-overflow-scrolling: touch;
  }
}
</style>

<script>
class PhotoGallery {
  constructor() {
    this.photos = [];
    this.currentLightboxIndex = 0;
    this.currentGridSize = this.getStoredGridSize();
    
    // Touch gesture properties
    this.touchStartX = 0;
    this.touchStartY = 0;
    this.touchDistance = 0;
    
    this.init();
  }

  async init() {
    this.setupEventListeners();
    await this.loadPhotos();
  }

  setupEventListeners() {
    // Retry button
    const retryBtn = document.getElementById('retry-btn');
    if (retryBtn) {
      retryBtn.addEventListener('click', () => this.loadPhotos());
    }

    // Grid size buttons
    document.querySelectorAll('.grid-size-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const size = e.currentTarget.dataset.size;
        this.setGridSize(size);
      });
    });

    // Lightbox controls
    const lightboxClose = document.getElementById('lightbox-close');
    const lightboxPrev = document.getElementById('lightbox-prev');
    const lightboxNext = document.getElementById('lightbox-next');
    const downloadOriginal = document.getElementById('download-original');
    const lightbox = document.getElementById('lightbox');

    if (lightboxClose) {
      lightboxClose.addEventListener('click', () => this.closeLightbox());
    }

    if (lightboxPrev) {
      lightboxPrev.addEventListener('click', () => this.previousPhoto());
    }

    if (lightboxNext) {
      lightboxNext.addEventListener('click', () => this.nextPhoto());
    }

    if (downloadOriginal) {
      downloadOriginal.addEventListener('click', () => this.downloadOriginal());
    }

    if (lightbox) {
      lightbox.addEventListener('click', (e) => {
        if (e.target === lightbox) {
          this.closeLightbox();
        }
      });
      
      // Mobile touch gestures for lightbox
      this.setupMobileGestures(lightbox);
    }

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (lightbox && !lightbox.classList.contains('hidden')) {
        if (e.key === 'Escape') {
          this.closeLightbox();
        } else if (e.key === 'ArrowLeft') {
          this.previousPhoto();
        } else if (e.key === 'ArrowRight') {
          this.nextPhoto();
        }
      }
    });
  }

  async loadPhotos() {
    const loading = document.getElementById('loading');
    const error = document.getElementById('error');
    const photoGrid = document.getElementById('photo-grid');
    const emptyState = document.getElementById('empty-state');

    // Show loading state
    loading.classList.remove('hidden');
    error.classList.add('hidden');
    photoGrid.classList.add('hidden');
    emptyState.classList.add('hidden');

    try {
      const response = await fetch('/api/photos?per_page=400');
      if (!response.ok) {
        throw new Error('Failed to fetch photos');
      }

      const data = await response.json();
      this.photos = data.result?.images || [];

      loading.classList.add('hidden');

      if (this.photos.length === 0) {
        emptyState.classList.remove('hidden');
      } else {
        this.renderPhotos();
        photoGrid.classList.remove('hidden');
        this.updatePhotoCount();
        this.initGridSize();
      }
    } catch (err) {
      loading.classList.add('hidden');
      error.classList.remove('hidden');
      console.error('Error loading photos:', err);
    }
  }

  renderPhotos() {
    const photoGrid = document.getElementById('photo-grid');
    if (!photoGrid) return;

    photoGrid.innerHTML = this.photos.map((photo, index) => {
      // Use the original public variant URL
      const thumbnailUrl = photo.variants.find(v => v.includes('public')) || photo.variants[0];

      return `
        <div class="photo-item group cursor-pointer" data-index="${index}">
          <div class="relative overflow-hidden rounded-lg aspect-square bg-gray-200 will-change-transform">
            <div class="lazy-image-container w-full h-full" data-src="${thumbnailUrl}">
              <div class="lazy-placeholder w-full h-full flex items-center justify-center">
                <div class="animate-pulse bg-gray-300 w-full h-full rounded-lg"></div>
              </div>
            </div>
            <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-20 transition-opacity duration-300 rounded-lg"></div>
            <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity duration-300">
              <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/>
                <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd"/>
              </svg>
            </div>
          </div>
        </div>
      `;
    }).join('');

    // Add click listeners to photo items
    photoGrid.querySelectorAll('.photo-item').forEach((item, index) => {
      item.addEventListener('click', () => this.openLightbox(index));
    });

    // Initialize lazy loading
    this.initLazyLoading();
    
    // Preload first few images for instant display
    this.preloadFirstImages();
  }

  openLightbox(index) {
    console.log('Opening lightbox for index:', index);
    this.currentLightboxIndex = index;
    
    // Cancel any existing high-res timers first
    if (this.currentHighResTimeout) {
      clearTimeout(this.currentHighResTimeout);
      this.currentHighResTimeout = null;
    }
    const lightbox = document.getElementById('lightbox');
    const lightboxImage = document.getElementById('lightbox-image');
    const lightboxPrev = document.getElementById('lightbox-prev');
    const lightboxNext = document.getElementById('lightbox-next');
    const currentPhoto = document.getElementById('current-photo');
    const totalPhotos = document.getElementById('total-photos');

    if (lightbox && lightboxImage && this.photos[index]) {
      const photo = this.photos[index];
      // Try different Cloudflare Images variant formats to find one that works
      const baseUrl = photo.variants.find(v => v.includes('public')) || photo.variants[0];
      const urlParts = baseUrl.split('/');
      
      let fullSizeVariant = baseUrl; // Default fallback
      
      if (urlParts.length >= 6) {
        const accountHash = urlParts[3];
        const imageId = urlParts[4];
        
        // Try various Cloudflare Images variant formats
        const variantFormats = [
          'width=2560',           // Standard width parameter
          'w=2560',              // Short width parameter  
          'scale-down',          // Built-in variant
          'public'               // Original working variant
        ];
        
        // For now, let's try the most common format: width=2560
        fullSizeVariant = `https://imagedelivery.net/${accountHash}/${imageId}/width=2560`;
        console.log('Trying variant URL:', fullSizeVariant);
      }
      
      // Smart loading: show standard quality first, upgrade only when needed
      
      // Step 1: Immediately show the original resolution (fast)
      lightboxImage.src = baseUrl;
      lightboxImage.style.opacity = '1';
      
      // Step 2: Set up high-res loading triggers
      if (fullSizeVariant !== baseUrl) {
        let highResLoaded = false;
        let highResLoading = false;
        
        const loadHighRes = () => {
          if (highResLoading || highResLoaded) return;
          
          console.log('Loading high-res version...');
          highResLoading = true;
          
          const highResImg = new Image();
          
          highResImg.onload = () => {
            console.log('High-res loaded, upgrading image quality');
            highResLoaded = true;
            
            // Very subtle transition
            lightboxImage.style.transition = 'opacity 0.1s ease';
            lightboxImage.style.opacity = '0.98';
            
            setTimeout(() => {
              lightboxImage.src = fullSizeVariant;
              lightboxImage.style.opacity = '1';
            }, 50);
          };
          
          highResImg.onerror = () => {
            console.log('High-res variant failed, staying with original quality');
            highResLoading = false;
          };
          
          highResImg.src = fullSizeVariant;
        };
        
        // Trigger 1: Load high-res after 2 seconds of viewing
        this.currentHighResTimeout = setTimeout(loadHighRes, 2000);
        
        // Store handler for cleanup
        this.touchStartHandler = (e) => {
          if (e.touches.length >= 2) { // Multi-touch = likely zoom
            if (this.currentHighResTimeout) {
              clearTimeout(this.currentHighResTimeout);
              this.currentHighResTimeout = null;
            }
            loadHighRes();
          }
        };
        
        // Trigger 2: Load high-res on any touch interaction (pinch, zoom gestures)
        lightboxImage.addEventListener('touchstart', this.touchStartHandler);
        
        // Clean up timeout and listeners if user closes lightbox
        const originalCloseLightbox = this.closeLightbox.bind(this);
        this.closeLightbox = () => {
          if (this.currentHighResTimeout) {
            clearTimeout(this.currentHighResTimeout);
            this.currentHighResTimeout = null;
          }
          // Remove touch listeners to prevent interference
          if (lightboxImage && this.touchStartHandler) {
            lightboxImage.removeEventListener('touchstart', this.touchStartHandler);
          }
          this.closeLightbox = originalCloseLightbox; // Restore original
          originalCloseLightbox();
        };
      }
      lightbox.classList.remove('hidden');
      document.body.style.overflow = 'hidden';

      // Update navigation buttons visibility
      if (this.photos.length > 1) {
        lightboxPrev.classList.remove('hidden');
        lightboxNext.classList.remove('hidden');
      } else {
        lightboxPrev.classList.add('hidden');
        lightboxNext.classList.add('hidden');
      }

      // Update counter
      currentPhoto.textContent = index + 1;
      totalPhotos.textContent = this.photos.length;
    }
  }

  closeLightbox() {
    const lightbox = document.getElementById('lightbox');
    if (lightbox) {
      lightbox.classList.add('hidden');
      document.body.style.overflow = '';
    }
  }

  previousPhoto() {
    if (this.photos.length > 0) {
      this.currentLightboxIndex = (this.currentLightboxIndex - 1 + this.photos.length) % this.photos.length;
      console.log('Previous photo - moving to index:', this.currentLightboxIndex);
      this.openLightbox(this.currentLightboxIndex);
    }
  }

  nextPhoto() {
    if (this.photos.length > 0) {
      this.currentLightboxIndex = (this.currentLightboxIndex + 1) % this.photos.length;
      console.log('Next photo - moving to index:', this.currentLightboxIndex);
      this.openLightbox(this.currentLightboxIndex);
    }
  }

  initLazyLoading() {
    // Create Intersection Observer with mobile-optimized settings
    const isMobile = window.innerWidth < 640;
    
    const imageObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const container = entry.target;
          const imageSrc = container.dataset.src;
          
          this.loadImage(container, imageSrc);
          observer.unobserve(container);
        }
      });
    }, {
      // More aggressive preloading on mobile due to single column scrolling
      rootMargin: isMobile ? '800px 0px' : '500px 0px',
      threshold: 0.01
    });
    
    console.log(`Lazy loading with ${isMobile ? '800px' : '500px'} rootMargin`);
    
    // Also preload on scroll for mobile - start loading next batch earlier
    if (isMobile) {
      let scrollTimeout;
      const scrollHandler = () => {
        // Don't preload if lightbox is open
        const lightbox = document.getElementById('lightbox');
        if (lightbox && !lightbox.classList.contains('hidden')) {
          return;
        }
        
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          this.preloadOnScroll();
        }, 100);
      };
      
      window.addEventListener('scroll', scrollHandler, { passive: true });
    }

    // Observe all lazy image containers
    document.querySelectorAll('.lazy-image-container').forEach(container => {
      imageObserver.observe(container);
    });
  }

  loadImage(container, src) {
    const img = new Image();
    
    img.onload = () => {
      // Use transform instead of innerHTML to avoid layout shift
      const placeholder = container.querySelector('.lazy-placeholder');
      if (placeholder) {
        // Create image element with proper containment
        const imgElement = document.createElement('img');
        imgElement.src = src;
        imgElement.alt = 'Wedding photo';
        imgElement.className = 'w-full h-full object-cover transition-transform duration-300 group-hover:scale-110 will-change-transform';
        imgElement.style.opacity = '0';
        imgElement.style.transform = 'translateZ(0)'; // Force GPU acceleration
        
        // Insert image and fade out placeholder
        container.appendChild(imgElement);
        
        // Use requestAnimationFrame for smooth transition
        requestAnimationFrame(() => {
          imgElement.style.transition = 'opacity 0.2s ease-out';
          imgElement.style.opacity = '1';
          placeholder.style.transition = 'opacity 0.2s ease-out';
          placeholder.style.opacity = '0';
          
          // Remove placeholder after transition
          setTimeout(() => {
            if (placeholder && placeholder.parentNode) {
              placeholder.remove();
            }
          }, 200);
        });
        
        // Add error handling
        imgElement.addEventListener('error', () => {
          imgElement.remove();
          placeholder.style.opacity = '1';
          placeholder.innerHTML = `
            <div class="w-full h-full flex items-center justify-center text-gray-400">
              <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd"/>
              </svg>
            </div>
          `;
        });
      }
    };

    img.onerror = () => {
      // Show error placeholder
      const placeholder = container.querySelector('.lazy-placeholder');
      if (placeholder) {
        placeholder.innerHTML = `
          <div class="w-full h-full flex items-center justify-center text-gray-400">
            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd"/>
            </svg>
          </div>
        `;
      }
    };

    // Start loading the image
    img.src = src;
  }

  preloadFirstImages() {
    // More aggressive preloading for mobile - preload more images upfront
    const firstImages = document.querySelectorAll('.lazy-image-container');
    
    // Mobile: preload first 15 images (single column = more vertical scrolling)
    // Desktop: preload first 12 images (multiple columns)
    const isMobile = window.innerWidth < 640;
    const preloadCount = Math.min(isMobile ? 15 : 12, firstImages.length);
    
    console.log(`Preloading ${preloadCount} images for ${isMobile ? 'mobile' : 'desktop'}`);
    
    for (let i = 0; i < preloadCount; i++) {
      const container = firstImages[i];
      const imageSrc = container.dataset.src;
      if (imageSrc) {
        this.loadImage(container, imageSrc);
      }
    }
  }

  preloadOnScroll() {
    // Find images that are close to viewport and not yet loaded
    const containers = document.querySelectorAll('.lazy-image-container');
    const viewportHeight = window.innerHeight;
    const scrollTop = window.scrollY;
    
    containers.forEach(container => {
      // Skip if already loaded (has img element)
      if (container.querySelector('img')) return;
      
      const rect = container.getBoundingClientRect();
      const distanceFromViewport = rect.top + scrollTop - (scrollTop + viewportHeight);
      
      // Preload if within 1200px of becoming visible
      if (distanceFromViewport < 1200) {
        const imageSrc = container.dataset.src;
        if (imageSrc) {
          this.loadImage(container, imageSrc);
        }
      }
    });
  }

  setupMobileGestures(lightbox) {
    // Touch start - record initial touch position
    lightbox.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        // Single touch for swipe
        this.touchStartX = e.touches[0].clientX;
        this.touchStartY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        // Two finger pinch - record distance
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        this.touchDistance = Math.sqrt(
          Math.pow(touch2.clientX - touch1.clientX, 2) +
          Math.pow(touch2.clientY - touch1.clientY, 2)
        );
      }
    }, { passive: true });

    // Touch move - prevent scrolling during swipe
    lightbox.addEventListener('touchmove', (e) => {
      if (e.touches.length === 1) {
        // Prevent scrolling during horizontal swipe
        const touchCurrentX = e.touches[0].clientX;
        const touchCurrentY = e.touches[0].clientY;
        const deltaX = Math.abs(touchCurrentX - this.touchStartX);
        const deltaY = Math.abs(touchCurrentY - this.touchStartY);
        
        // If horizontal movement is greater than vertical, prevent scrolling
        if (deltaX > deltaY && deltaX > 10) {
          e.preventDefault();
        }
      }
    });

    // Touch end - detect swipe or pinch gestures
    lightbox.addEventListener('touchend', (e) => {
      if (e.changedTouches.length === 1 && this.touchStartX !== 0) {
        // Single finger swipe
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = this.touchStartX - touchEndX;
        const deltaY = Math.abs(this.touchStartY - touchEndY);
        
        // Minimum swipe distance and ensure it's more horizontal than vertical
        if (Math.abs(deltaX) > 50 && Math.abs(deltaX) > deltaY) {
          if (deltaX > 0) {
            // Swipe left = next photo
            this.nextPhoto();
          } else {
            // Swipe right = previous photo
            this.previousPhoto();
          }
        }
        
        // Reset touch tracking
        this.touchStartX = 0;
        this.touchStartY = 0;
      } else if (e.touches.length === 0 && this.touchDistance > 0) {
        // End of pinch gesture - could add pinch to zoom here
        this.touchDistance = 0;
      }
    }, { passive: true });

    // Pinch gesture detection (for future zoom functionality)
    lightbox.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2 && this.touchDistance > 0) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentDistance = Math.sqrt(
          Math.pow(touch2.clientX - touch1.clientX, 2) +
          Math.pow(touch2.clientY - touch1.clientY, 2)
        );
        
        // Detect pinch in (zoom out) - could close lightbox
        if (currentDistance < this.touchDistance * 0.7) {
          this.closeLightbox();
          this.touchDistance = 0;
        }
      }
    }, { passive: true });
  }

  getStoredGridSize() {
    return localStorage.getItem('photoGalleryGridSize') || '4';
  }

  setGridSize(size) {
    this.currentGridSize = size;
    localStorage.setItem('photoGalleryGridSize', size);
    
    // Update grid data attribute
    const photoGrid = document.getElementById('photo-grid');
    if (photoGrid) {
      photoGrid.setAttribute('data-size', size);
    }
    
    // Update button states
    document.querySelectorAll('.grid-size-btn').forEach(btn => {
      if (btn.dataset.size === size) {
        btn.classList.add('bg-gray-800', 'text-white');
        btn.classList.remove('text-gray-600');
      } else {
        btn.classList.remove('bg-gray-800', 'text-white');
        btn.classList.add('text-gray-600');
      }
    });
  }

  initGridSize() {
    this.setGridSize(this.currentGridSize);
  }

  updatePhotoCount() {
    const photoCount = document.getElementById('photo-count');
    const photoCountMobile = document.getElementById('photo-count-mobile');
    
    if (photoCount) {
      photoCount.textContent = this.photos.length;
    }
    if (photoCountMobile) {
      photoCountMobile.textContent = this.photos.length;
    }
  }

  async downloadOriginal() {
    if (this.photos[this.currentLightboxIndex]) {
      const photo = this.photos[this.currentLightboxIndex];
      console.log('Downloading photo:', photo);
      
      const downloadUrl = `/api/photos/download?id=${photo.id}`;
      console.log('Download URL:', downloadUrl);
      
      try {
        // First test if the API endpoint is working
        const response = await fetch(downloadUrl);
        console.log('API Response status:', response.status);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Download API error:', errorText);
          alert(`Download failed: ${response.status} - ${errorText}`);
          return;
        }
        
        // If the API works, download the file
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `wedding-photo-${photo.id}.jpg`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
        
      } catch (error) {
        console.error('Download failed:', error);
        alert('Download failed. Please check the console for details.');
      }
    } else {
      console.error('No photo found at current index:', this.currentLightboxIndex);
    }
  }
}

// Initialize the photo gallery when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  new PhotoGallery();
});
</script>